import {
  Controller,
  Get,
  Post,
  Patch,
  Body,
  Param,
  Query,
  UseGuards,
  Request,
  Req,
} from '@nestjs/common';
import { ThrottlerGuard } from '@nestjs/throttler';
import { Request as ExpressRequest } from 'express';
import { AuthGuard } from '../../auth/middleware/auth.guard';
import { EscrowAccessGuard } from '../guards/escrow-access.guard';
import { EscrowService } from '../services/escrow.service';
import { CreateEscrowDto } from '../dto/create-escrow.dto';
import { UpdateEscrowDto } from '../dto/update-escrow.dto';
import { ListEscrowsDto } from '../dto/list-escrows.dto';
import { CancelEscrowDto } from '../dto/cancel-escrow.dto';
import { FileDisputeDto, ResolveDisputeDto } from '../dto/dispute.dto';

interface AuthenticatedRequest extends ExpressRequest {
  user: { sub: string; walletAddress: string };
}

@Controller('escrows')
@UseGuards(ThrottlerGuard, AuthGuard)
export class EscrowController {
  constructor(private readonly escrowService: EscrowService) {}

  @Post()
  async create(
    @Body() dto: CreateEscrowDto,
    @Request() req: AuthenticatedRequest,
  ) {
    const userId = req.user.sub;
    const ipAddress = req.ip || req.socket?.remoteAddress;
    return this.escrowService.create(dto, userId, ipAddress);
  }

  @Get()
  async findAll(
    @Query() query: ListEscrowsDto,
    @Request() req: AuthenticatedRequest,
  ) {
    const userId = req.user.sub;
    return this.escrowService.findAll(userId, query);
  }

  @Get(':id')
  @UseGuards(EscrowAccessGuard)
  async findOne(@Param('id') id: string) {
    return this.escrowService.findOne(id);
  }

  @Patch(':id')
  @UseGuards(EscrowAccessGuard)
  async update(
    @Param('id') id: string,
    @Body() dto: UpdateEscrowDto,
    @Request() req: AuthenticatedRequest,
  ) {
    const userId = req.user.sub;
    const ipAddress = req.ip || req.socket?.remoteAddress;
    return this.escrowService.update(id, dto, userId, ipAddress);
  }

  @Post(':id/cancel')
  @UseGuards(EscrowAccessGuard)
  async cancel(
    @Param('id') id: string,
    @Body() dto: CancelEscrowDto,
    @Request() req: AuthenticatedRequest,
  ) {
    const userId = req.user.sub;
    const ipAddress = req.ip || req.socket?.remoteAddress;
    return this.escrowService.cancel(id, dto, userId, ipAddress);
  }

  @Post(':id/release')
  @UseGuards(AuthGuard)
  async releaseEscrow(
    @Param('id') id: string,
    @Req() req: AuthenticatedRequest,
  ) {
    const escrow = await this.escrowService.releaseEscrow(
      id,
      req.user.sub,
      true, // manual trigger
    );

    return {
      id: escrow.id,
      status: escrow.status,
      transactionHash: escrow.releaseTransactionHash,
    };
  }

  /**
   * POST /escrows/:id/dispute
   * File a dispute against an active escrow. Only a buyer or seller party may call this.
   * Transitions the escrow from ACTIVE → DISPUTED and freezes fund release.
   */
  @Post(':id/dispute')
  @UseGuards(EscrowAccessGuard)
  async fileDispute(
    @Param('id') id: string,
    @Body() dto: FileDisputeDto,
    @Request() req: AuthenticatedRequest,
  ) {
    const ipAddress = req.ip || req.socket?.remoteAddress;
    return this.escrowService.fileDispute(id, req.user.sub, dto, ipAddress);
  }

  /**
   * GET /escrows/:id/dispute
   * Retrieve the dispute record for an escrow. Accessible to any party on the escrow.
   */
  @Get(':id/dispute')
  @UseGuards(EscrowAccessGuard)
  async getDispute(@Param('id') id: string) {
    return this.escrowService.getDispute(id);
  }

  /**
   * POST /escrows/:id/dispute/resolve
   * Resolve an open dispute. Only an assigned arbitrator party may call this.
   * Transitions the escrow from DISPUTED → COMPLETED (release/split) or CANCELLED (refund).
   */
  @Post(':id/dispute/resolve')
  @UseGuards(EscrowAccessGuard)
  async resolveDispute(
    @Param('id') id: string,
    @Body() dto: ResolveDisputeDto,
    @Request() req: AuthenticatedRequest,
  ) {
    const ipAddress = req.ip || req.socket?.remoteAddress;
    return this.escrowService.resolveDispute(id, req.user.sub, dto, ipAddress);
  }
}
